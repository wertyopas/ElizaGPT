<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Assistant ↔ Eliza — Continuous Conversation Demo</title>
  <style>
    body{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:0;background:#0f172a;color:#e6eef8}
    header{padding:20px;background:linear-gradient(90deg,#0b1220,#112236);box-shadow:0 2px 8px rgba(2,6,23,.6)}
    .container{max-width:900px;margin:24px auto;padding:16px}
    .panel{background:#061124;border-radius:12px;padding:14px;box-shadow:0 6px 18px rgba(2,6,23,.6)}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
    input,select,button{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,.06);background:#081426;color:inherit}
    button{cursor:pointer}
    #log{height:420px;overflow:auto;padding:12px;background:linear-gradient(180deg,#041025,#071726);border-radius:8px;border:1px solid rgba(255,255,255,.02)}
    .msg{margin:8px 0;padding:10px;border-radius:10px;max-width:85%}
    .from-assistant{background:linear-gradient(90deg,#2a60ff22,#2a60ff11);align-self:flex-end}
    .from-eliza{background:linear-gradient(90deg,#28a74522,#28a74511)}
    .meta{font-size:12px;opacity:.7;margin-bottom:6px}
    footer{margin-top:12px;font-size:13px;opacity:.85}
    label{font-size:13px}
  </style>
</head>
<body>
  <header>
    <div style="max-width:900px;margin:0 auto;color:#d8e9ff">
      <h1 style="margin:0;font-size:20px">Assistant ↔ Eliza — Continuous Conversation Demo</h1>
      <p style="margin:6px 0 0;color:#9fb3d8;font-size:13px">Run an automated conversation that alternates between a human-like assistant (optionally powered by OpenAI) and a local Eliza implementation.</p>
    </div>
  </header>

  <main class="container">
    <div class="panel">
      <div class="controls">
        <button id="startBtn">Start</button>
        <button id="pauseBtn">Pause</button>
        <button id="stepBtn">Step (single turn)</button>
        <button id="clearBtn">Clear</button>
        <label style="display:flex;align-items:center;gap:6px">Delay(ms)
          <input id="delay" type="number" value="1200" style="width:100px" />
        </label>
        <label style="display:flex;align-items:center;gap:6px">Mode
          <select id="mode">
            <option value="local">Local Assistant (no API)</option>
            <option value="openai">OpenAI (use API key)</option>
          </select>
        </label>
        <input id="openaiKey" placeholder="Paste OpenAI API key (optional)" style="min-width:240px" />
      </div>

      <div id="log"></div>
      <footer>
        <strong>Notes:</strong> If you choose OpenAI mode, the page will call the OpenAI REST API from your browser with the key you paste here — do not paste secrets you don't control. Running "forever" will consume your API quota and may cost money. Use a reasonable delay, and pause when needed.
      </footer>
    </div>
  </main>

  <script>
  // --- Simple ELIZA implementation (classic script inspired) ---
  // This is intentionally self-contained and lightweight.
  const eliza = (function(){
    // A tiny set of reflections and rules for demonstration.
    const reflections = {"am":"are","was":"were","i":"you","i'd":"you would","i've":"you have","i'll":"you will","my":"your","are":"am","you":"me","me":"you"};
    function reflect(fragment){
      return fragment.split(/\s+/).map(w=>reflections[w.toLowerCase()]||w).join(' ');
    }

    const rules = [
      {pattern:/^I need (.*)/i, reply:["Why do you need %1?","Would it really help you to get %1?","Are you sure you need %1?"]},
      {pattern:/^Why don't you (.*)/i, reply:["Do you really think I don't %1?","Perhaps eventually I will %1."]},
      {pattern:/^Why can't I (.*)/i, reply:["Do you think you should be able to %1?","If you could %1, what would you do?"]},
      {pattern:/^I can't (.*)/i, reply:["How do you know you can't %1?","Perhaps you could %1 if you tried."]},
      {pattern:/^I'm (.*)/i, reply:["How long have you been %1?","Do you enjoy being %1?"]},
      {pattern:/^I am (.*)/i, reply:["How does being %1 make you feel?","Do you often feel %1?"]},
      {pattern:/^Because (.*)/i, reply:["Is that the real reason?","Does that reason explain everything?"]},
      {pattern:/(.*)mother(.*)/i, reply:["Tell me more about your mother."]},
      {pattern:/(.*)father(.*)/i, reply:["Tell me more about your father."]},
      {pattern:/(.*)sorry(.*)/i, reply:["There are many times when no apology is needed."]},
      {pattern:/(.*)hello(.*)/i, reply:["Hello... I'm glad you could drop by today."]},
      {pattern:/(.*)\b(yes|yeah|yep)\b(.*)/i, reply:["You seem quite sure."]},
      {pattern:/^(.*)\?$/i, reply:["Why do you ask that?","What do you think?"]},
      {pattern:/(.*)/i, reply:["Tell me more about that.","Let's change focus a bit — tell me about your family.","Why do you say that %1?" ]}
    ];

    return function(input){
      input = input.trim();
      for(const r of rules){
        const m = input.match(r.pattern);
        if(m){
          const reply = r.reply[Math.floor(Math.random()*r.reply.length)];
          // replace %1 with captured group if present
          return reply.replace(/%1/g, reflect(m[1] || "")).replace(/\s+/g,' ').trim();
        }
      }
      return "I'm not sure I understand you fully.";
    }
  })();

  // --- Local assistant fallback (very simple, won't be as smart as a real GPT) ---
  function localAssistantReply(contextText){
    // Heuristics: try to reframe, ask a question, or mirror.
    const templates = [
      "That's interesting — can you expand on '%s'?",
      "You said: '%s'. Why is that important to you?",
      "How does '%s' make you feel?",
      "Let's explore that more: what happened next?",
      "Hmm. When you say '%s', what do you mean exactly?"
    ];
    // take last user-like sentence from context
    const last = (contextText||'').split(/\n/).slice(-1)[0] || 'that';
    const t = templates[Math.floor(Math.random()*templates.length)];
    return t.replace('%s', last.slice(0,140));
  }

  // --- UI helpers & conversation loop ---
  const logEl = document.getElementById('log');
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const stepBtn = document.getElementById('stepBtn');
  const clearBtn = document.getElementById('clearBtn');
  const delayInput = document.getElementById('delay');
  const modeSel = document.getElementById('mode');
  const openaiKeyInput = document.getElementById('openaiKey');

  let running = false;
  let loopHandle = null;
  let convo = []; // {speaker:'assistant'|'eliza', text}

  function appendMessage(speaker,text){
    convo.push({speaker,text});
    const d = document.createElement('div');
    d.className='msg '+(speaker==='assistant'?'from-assistant':'from-eliza');
    const meta = document.createElement('div');meta.className='meta';meta.textContent = speaker.toUpperCase();
    const t = document.createElement('div');t.textContent = text;
    d.appendChild(meta);d.appendChild(t);logEl.appendChild(d);
    logEl.scrollTop = logEl.scrollHeight;
  }

  async function generateAssistantReply(contextText){
    if(modeSel.value==='local' || !openaiKeyInput.value.trim()){
      return localAssistantReply(contextText);
    }
    // OpenAI mode: call API from browser using the provided key.
    const key = openaiKeyInput.value.trim();
    const payload = {
      model: 'gpt-4o-mini',
      messages:[
        {role:'system',content:'You are a helpful conversational assistant. You are having a continuous conversation with an Eliza-style chatbot. Keep replies short (1-2 sentences).'},
        {role:'user',content:contextText}
      ],
      max_tokens:200
    };
    try{
      const res = await fetch('https://api.openai.com/v1/chat/completions',{method:'POST',headers:{'Content-Type':'application/json','Authorization':'Bearer '+key},body:JSON.stringify(payload)});
      if(!res.ok){
        const t = await res.text();
        console.warn('OpenAI error',res.status,t);
        return '[[OpenAI error: '+res.status+']]';
      }
      const data = await res.json();
      const txt = data.choices?.[0]?.message?.content || JSON.stringify(data);
      return txt.replace(/\n+/g,' ').slice(0,800);
    }catch(e){
      console.error(e);
      return '[[Network/API error]]';
    }
  }

  async function elizaReply(lastAssistant){
    return eliza(lastAssistant || '');
  }

  async function singleTurn(){
    // assistant -> eliza
    const assistantContext = convo.map(c=>`${c.speaker}: ${c.text}`).join('\n');
    const assistantText = await generateAssistantReply(assistantContext || 'Hello');
    appendMessage('assistant',assistantText);

    // small delay to make it readable
    await new Promise(r=>setTimeout(r,200));

    const elText = await elizaReply(assistantText);
    appendMessage('eliza',elText);
  }

  async function runLoop(){
    if(running) return;
    running = true; startBtn.disabled=true; pauseBtn.disabled=false;
    while(running){
      try{
        await singleTurn();
      }catch(e){console.error(e);appendMessage('assistant','[[Error during turn]]');}
      const delay = Math.max(200,parseInt(delayInput.value)||1200);
      await new Promise(r=>setTimeout(r,delay));
    }
  }

  startBtn.addEventListener('click',()=>{ if(!running) runLoop(); });
  pauseBtn.addEventListener('click',()=>{ running=false; startBtn.disabled=false; pauseBtn.disabled=true; });
  stepBtn.addEventListener('click',()=>{ singleTurn(); });
  clearBtn.addEventListener('click',()=>{ convo=[]; logEl.innerHTML=''; });

  // initial UI state
  pauseBtn.disabled = true;

  // starter greeting
  appendMessage('assistant','Hello — shall we begin?');
  appendMessage('eliza',eliza('Hello'));
  </script>
</body>
</html>
